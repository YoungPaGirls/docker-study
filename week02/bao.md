- 이미지 - 파일 시스템과 실행할 애플리케이션 설정을 하나로 합친 것. 컨테이너를 생성하는 템플릿 역할
- 컨테이너 - 이미지 기반으로 생성되고, 파일 시스템과 애플리케이션이 구체화돼 실행되는 상태

1. 도커 이미지 받아오기

```bash
docker image pull gihyodocker/echo:latest
```

1. 도커 실행하기

```bash
docker container run -t -p 9000:8080 gihyodocker/echo:latest
```

1. 터미널 하나 더 띄워서 떠졌는지 확인

```bash
curl http://localhost:9000
```

- 도커 이미지 만들고 > 이미지에서 컨테이너를 실행하고 > 포트 포워딩을 통해서 컨테이너 안에서 실행중인 애플리케이션을 사용하는 것임

## 간단한 애플리케이션과 도커 이미지 만들기

### FROM 인스트럭션

- 도커 이미지의 바탕이 될 베이스 이미지
- 이것은 도커 허브라는 레지스트리에 공개된 것이다
- 1.9 라고 된 부분은 태그인데, 각 이미지의 버전 등을 구별하는 식별자이다

### RUN 인스트럭션

- 컨테이너 안에서 실행할 명령을 정의하는 인스트럭션이다

### COPY 인스트럭션

- 도커가 동작 중인 호스트 머신의 파일이나 디렉터리를 도커 컨테이너 안으로 복사하는 것이다
- main.go 파일을 도커 컨테이너 안에서 실행할 수 있도록 복사했다
- RUN 인스트럭션에서 만든 echo 디렉터리로 복사했다

### CMD 인스트럭션

- 컨테이너 안에서 실행할 프로세스를 지정한다
- 애플리케이션 자체를 실행하는 명령이다
- 명령을 공백으로 나눈 배열로 나타낸다

## 도커 이미지 빌드하기

- docker image build 명령으로 도커 이미지를 빌드한다
- -t : 이미지명을 지정한다. 태그명도 지정할 수 있다
- 이미지명 없이는 해시값만으로 이미지를 구별해야 하므로 상당히 번거롭기 때문에 반드시 해 주는게 좋다

`docker image build -t 이미지명[:태그명] Dockerfile_경로`

/ 앞에 오는 example 은 네임스페이스다. 이미지명의 충돌을 피하기 위해서 네임스페이스를 붙여야 한다

`docker image build -t example/echo:latest .` 

docker iamge ls 로 생성된 이미지를 확인할 수 있다


## 도커 컨테이너 실행

- `docker container run example/echo:latest` 으로 실행
    - `docker run -it example/echo:latest` 이렇게 해야 ctrl+c 가 먹힘
        - 가상 터미널(TTY)이 연결되면서 **컨테이너 내부 프로세스가 직접 사용자의 입력(SIGINT 등)을 받을 수 있게 됨**.
- `docker container run -d example/echo:latest` 백그라운드 데몬으로 컨테이너를 실행
- `docker container ls`
    - 실행된 도커 목록 보기

## 포트 포워딩

- go 내용을 보면 애플리케이션이 8080 을 리스닝하는데 curl 때리면 8080이 refused 가 됨
- 도커 컨테이너는 가상 환경이지만, 외부에서 봤을 땐 독립된 하나의 머신처럼 다룰 수 있음
- echo 앱은 8080 을 리스닝하지만, 이 포트는 컨테이너 포트라고, 컨테이너 안에서 한정된 포트임
- curl 을 컨테이너 안에서 실행하면 응답이 오겠지만, 컨테이너 밖에서는 컨테이너 포트를 바로 사용할 수 없기 때문에 refusd 가 되는 거임
- 컨테이너 밖에서 온 요청을 컨테이너 안의 앱에 전달해 줘야 하는데, 그 역할이 바로 포트 포워딩임
    - 호스트 머신의 포트와 컨테이너 포트를 연결하는 것

`docker container run -d -p 9000:8080 example/echo:latest` 

- -p 옵션을 붙이면 포트 포워딩을 지정할 수 있다
- 컨테이너 밖에서 9000 으로 오는 걸 컨테이너 안의 8080 으로 붙여준 것임

# 도커 이미지 다루기

- 도커이미지는 도커 컨테이너를 만들기 위한 템플릿이다
- 실행 환경의 설정 정보를 포함하는 아카이브이다
- Dockerfile 은 이미지를 구성하는 코드이기 때문에, 이것은 이미지라고 할 수는 없다

### -t

- 이미지명과 태그명을 붙이는 것이다

### -f

- Dockerfile 외의 파일명으로 된 Dockerfile 을 사용할 때 쓰인다

### —pull

- 레지스트리에서 받아온 도커 이미지는 호스트 운영 체제에 저장되는데,   
이 옵션을 사용하면 매번 베이스 이미지를 강제로 새로 받아온다.
- 이것은 빌드 속도면에서는 불리하기 때문에 latest 로 지정하는 것은 피하는 것이 좋다

### docker search

- 도커 허브는 깃헙같이 리포지토리를 만들 수 있고, 이 리포로 도커 이미지를 관리한다
- docker search 로 도커 허브에 등록된 리포를 검색할 수 있다
- 검색 결과가 starts 순으로 출력된다
- 공식 리포의 네임스페이스는 library 가 국룰이라고 함

### docker image pull

- 이미지 내려받는 법

### docker image ls

- 보유한 도커 이미지 목록 보기
- docker image build 로  내려받은 이미지는 호스트 운영 체제에 저장됨

### docker image tag

- 특정 버전에 태그 붙일 때 사용
- 수정하거나 COPY 대상이 되는 파일의 내용이 바뀔 떄마다 IMAGE ID 가 바뀐다
    - 도커 이미지 버전보다는 엄밀히 말하면 IMAGE ID 이다
- 특정한 이미지를 쉽게 참조할 수 있도록 붙이는 별명이다
- git 의 커밋을 나타내는 해시와 같다고 생각하면 된다
- 보통 릴리즈 번호를 붙여서 이미지를 쉽게 관리한다

```bash
docker image tag example/echo:latest example/echo:0.1.0
```

### docker image push

- 이미지를 도커 허브에 올릴 때 사용한다
- 그 전에 먼저 네임스페이스를 바꿔야 한다
- 도커 허브는 소속 기관이 소유한 리포지토리에만 이미지를 등록할 수 있기 때문
- 공개 도커 허브는 누구나 이미지를 내려받을 수 있기 때문에 민감 정보는 올리지 말아야 한다